// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"time"
	"server/types"
)

const addApartment = `-- name: AddApartment :exec
;

INSERT INTO apartment (
  name, street, building_number, building_name, flat_number, owner_id
) VALUES(
  ?, ?, ?, ?, ?, ?
)
`

type AddApartmentParams struct {
	Name           string `json:"name"`
	Street         string `json:"street"`
	BuildingNumber string `json:"building_number"`
	BuildingName   string `json:"building_name"`
	FlatNumber     string `json:"flat_number"`
	OwnerID        int64  `json:"owner_id"`
}

func (q *Queries) AddApartment(ctx context.Context, arg AddApartmentParams) error {
	_, err := q.db.ExecContext(ctx, addApartment,
		arg.Name,
		arg.Street,
		arg.BuildingNumber,
		arg.BuildingName,
		arg.FlatNumber,
		arg.OwnerID,
	)
	return err
}

const addFault = `-- name: AddFault :exec
INSERT INTO fault_report (title, description, status_id, apartment_id, user_id) VALUES(?, ?, ?, ?, ?)
`

type AddFaultParams struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	StatusID    int64  `json:"status_id"`
	ApartmentID int64  `json:"apartment_id"`
	UserID      int64  `json:"user_id"`
}

func (q *Queries) AddFault(ctx context.Context, arg AddFaultParams) error {
	_, err := q.db.ExecContext(ctx, addFault,
		arg.Title,
		arg.Description,
		arg.StatusID,
		arg.ApartmentID,
		arg.UserID,
	)
	return err
}

const addNewRenting = `-- name: AddNewRenting :exec
INSERT INTO renting_history (apartment_id, user_id, start_date) VALUES(?, ?, ?)
`

type AddNewRentingParams struct {
	ApartmentID int64     `json:"apartment_id"`
	UserID      int64     `json:"user_id"`
	StartDate   time.Time `json:"start_date"`
}

func (q *Queries) AddNewRenting(ctx context.Context, arg AddNewRentingParams) error {
	_, err := q.db.ExecContext(ctx, addNewRenting, arg.ApartmentID, arg.UserID, arg.StartDate)
	return err
}

const addPayment = `-- name: AddPayment :exec
INSERT INTO payments (
  amount, due_date, renting_id
  ) VALUES (
  ?, ?, ?
)
`

type AddPaymentParams struct {
	Amount    float64   `json:"amount"`
	DueDate   time.Time `json:"due_date"`
	RentingID int64     `json:"renting_id"`
}

func (q *Queries) AddPayment(ctx context.Context, arg AddPaymentParams) error {
	_, err := q.db.ExecContext(ctx, addPayment, arg.Amount, arg.DueDate, arg.RentingID)
	return err
}

const addRepair = `-- name: AddRepair :exec
INSERT INTO repair (
  title, fault_report_id, date_assigned
) VALUES (
  ?, ?, ?
)
`

type AddRepairParams struct {
	Title         string    `json:"title"`
	FaultReportID int64     `json:"fault_report_id"`
	DateAssigned  time.Time `json:"date_assigned"`
}

func (q *Queries) AddRepair(ctx context.Context, arg AddRepairParams) error {
	_, err := q.db.ExecContext(ctx, addRepair, arg.Title, arg.FaultReportID, arg.DateAssigned)
	return err
}

const addSpec = `-- name: AddSpec :exec
INSERT INTO speciality (name) VALUES(?)
`

func (q *Queries) AddSpec(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, addSpec, name)
	return err
}

const addSubcontractor = `-- name: AddSubcontractor :exec
INSERT INTO subcontractor (
  user_id, address, NIP, speciality_id
) VALUES (
  ?, ?, ?, ?
)
`

type AddSubcontractorParams struct {
	UserID       int64  `json:"user_id"`
	Address      string `json:"address"`
	Nip          string `json:"nip"`
	SpecialityID int64  `json:"speciality_id"`
}

func (q *Queries) AddSubcontractor(ctx context.Context, arg AddSubcontractorParams) error {
	_, err := q.db.ExecContext(ctx, addSubcontractor,
		arg.UserID,
		arg.Address,
		arg.Nip,
		arg.SpecialityID,
	)
	return err
}

const addUser = `-- name: AddUser :exec
INSERT INTO user (name, password, email, phone, role_id) VALUES(?, ?, ?, ?, ?)
`

type AddUserParams struct {
	Name     string `json:"name"`
	Password string `json:"password"`
	Email    string `json:"email"`
	Phone    string `json:"phone"`
	RoleID   int64  `json:"role_id"`
}

func (q *Queries) AddUser(ctx context.Context, arg AddUserParams) error {
	_, err := q.db.ExecContext(ctx, addUser,
		arg.Name,
		arg.Password,
		arg.Email,
		arg.Phone,
		arg.RoleID,
	)
	return err
}

const changeRent1 = `-- name: ChangeRent1 :exec
UPDATE pricing_history
	SET is_current = 1
	WHERE is_current = 0 AND apartment_id = ?
`

func (q *Queries) ChangeRent1(ctx context.Context, apartmentID int64) error {
	_, err := q.db.ExecContext(ctx, changeRent1, apartmentID)
	return err
}

const changeRent2 = `-- name: ChangeRent2 :exec
INSERT INTO pricing_history (apartment_id, price) VALUES(?, ?)
`

type ChangeRent2Params struct {
	ApartmentID int64   `json:"apartment_id"`
	Price       float64 `json:"price"`
}

func (q *Queries) ChangeRent2(ctx context.Context, arg ChangeRent2Params) error {
	_, err := q.db.ExecContext(ctx, changeRent2, arg.ApartmentID, arg.Price)
	return err
}

const getActiveRenting = `-- name: GetActiveRenting :many
SELECT id, apartment_id, user_id, start_date, end_date FROM renting_history WHERE is_current = 1
`

type GetActiveRentingRow struct {
	ID          int64        `json:"id"`
	ApartmentID int64        `json:"apartment_id"`
	UserID      int64        `json:"user_id"`
	StartDate   time.Time    `json:"start_date"`
	EndDate     types.JSONNullTime `json:"end_date"`
}

func (q *Queries) GetActiveRenting(ctx context.Context) ([]GetActiveRentingRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRenting)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveRentingRow
	for rows.Next() {
		var i GetActiveRentingRow
		if err := rows.Scan(
			&i.ID,
			&i.ApartmentID,
			&i.UserID,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPayment = `-- name: GetAllPayment :many
SELECT id, amount, payment_date, due_date, status_id, renting_id, transaction_reference FROM payments
`

func (q *Queries) GetAllPayment(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getAllPayment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.PaymentDate,
			&i.DueDate,
			&i.StatusID,
			&i.RentingID,
			&i.TransactionReference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApartmentID = `-- name: GetApartmentID :one
SELECT apartment_id FROM renting_history 
WHERE is_current IS 1 AND user_id = ?
`

func (q *Queries) GetApartmentID(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getApartmentID, userID)
	var apartment_id int64
	err := row.Scan(&apartment_id)
	return apartment_id, err
}

const getApartments = `-- name: GetApartments :many
SELECT id, name, street, building_number, building_name, flat_number, owner_id
FROM apartment
`

func (q *Queries) GetApartments(ctx context.Context) ([]Apartment, error) {
	rows, err := q.db.QueryContext(ctx, getApartments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apartment
	for rows.Next() {
		var i Apartment
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Street,
			&i.BuildingNumber,
			&i.BuildingName,
			&i.FlatNumber,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApartmentsAndRent = `-- name: GetApartmentsAndRent :many
SELECT apartment.id, apartment.name, apartment.street, apartment.building_number, apartment.building_name, apartment.flat_number, apartment.owner_id, pricing_history.price FROM apartment
LEFT JOIN pricing_history ON pricing_history.apartment_id = apartment.id
WHERE pricing_history.is_current = 1
`

type GetApartmentsAndRentRow struct {
	ID             int64           `json:"id"`
	Name           string          `json:"name"`
	Street         string          `json:"street"`
	BuildingNumber string          `json:"building_number"`
	BuildingName   string          `json:"building_name"`
	FlatNumber     string          `json:"flat_number"`
	OwnerID        int64           `json:"owner_id"`
	Price          types.JSONNullFloat `json:"price"`
}

func (q *Queries) GetApartmentsAndRent(ctx context.Context) ([]GetApartmentsAndRentRow, error) {
	rows, err := q.db.QueryContext(ctx, getApartmentsAndRent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApartmentsAndRentRow
	for rows.Next() {
		var i GetApartmentsAndRentRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Street,
			&i.BuildingNumber,
			&i.BuildingName,
			&i.FlatNumber,
			&i.OwnerID,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFaultReports = `-- name: GetFaultReports :many
SELECT fault_report.id, fault_report.title, fault_report.description, fault_report.date_reported, fault_report.status_id, fault_report.apartment_id, fault_report.user_id, apartment.name FROM fault_report
INNER JOIN apartment ON apartment.id = fault_report.apartment_id
`

type GetFaultReportsRow struct {
	ID           int64     `json:"id"`
	Title        string    `json:"title"`
	Description  string    `json:"description"`
	DateReported time.Time `json:"date_reported"`
	StatusID     int64     `json:"status_id"`
	ApartmentID  int64     `json:"apartment_id"`
	UserID       int64     `json:"user_id"`
	Name         string    `json:"name"`
}

func (q *Queries) GetFaultReports(ctx context.Context) ([]GetFaultReportsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFaultReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFaultReportsRow
	for rows.Next() {
		var i GetFaultReportsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.DateReported,
			&i.StatusID,
			&i.ApartmentID,
			&i.UserID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFaultReportsUser = `-- name: GetFaultReportsUser :many
SELECT fault_report.id, fault_report.title, fault_report.description, fault_report.date_reported, fault_report.status_id, fault_report.apartment_id, fault_report.user_id, apartment.name FROM fault_report
INNER JOIN apartment ON apartment.id = fault_report.apartment_id
WHERE fault_report.apartment_id = ?
`

type GetFaultReportsUserRow struct {
	ID           int64     `json:"id"`
	Title        string    `json:"title"`
	Description  string    `json:"description"`
	DateReported time.Time `json:"date_reported"`
	StatusID     int64     `json:"status_id"`
	ApartmentID  int64     `json:"apartment_id"`
	UserID       int64     `json:"user_id"`
	Name         string    `json:"name"`
}

func (q *Queries) GetFaultReportsUser(ctx context.Context, apartmentID int64) ([]GetFaultReportsUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getFaultReportsUser, apartmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFaultReportsUserRow
	for rows.Next() {
		var i GetFaultReportsUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.DateReported,
			&i.StatusID,
			&i.ApartmentID,
			&i.UserID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverduePayments = `-- name: GetOverduePayments :many
SELECT id, amount, payment_date, due_date, status_id, renting_id, transaction_reference
FROM payments
WHERE status_id = 3
`

func (q *Queries) GetOverduePayments(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getOverduePayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.PaymentDate,
			&i.DueDate,
			&i.StatusID,
			&i.RentingID,
			&i.TransactionReference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayments = `-- name: GetPayments :many
SELECT id, amount, payment_date, due_date, status_id, renting_id, transaction_reference
FROM payments
WHERE renting_id = ?
`

func (q *Queries) GetPayments(ctx context.Context, rentingID int64) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getPayments, rentingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.PaymentDate,
			&i.DueDate,
			&i.StatusID,
			&i.RentingID,
			&i.TransactionReference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsId = `-- name: GetPaymentsId :many
SELECT id, amount, payment_date, due_date, status_id, renting_id, transaction_reference
FROM payments
WHERE renting_id = (SELECT id FROM renting_history WHERE user_id = ?)
`

func (q *Queries) GetPaymentsId(ctx context.Context, userID int64) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentsId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.PaymentDate,
			&i.DueDate,
			&i.StatusID,
			&i.RentingID,
			&i.TransactionReference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPaymants = `-- name: GetPendingPaymants :many
SELECT id, amount, payment_date, due_date, status_id, renting_id, transaction_reference
FROM payments
WHERE status_id = 1
`

func (q *Queries) GetPendingPaymants(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getPendingPaymants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.PaymentDate,
			&i.DueDate,
			&i.StatusID,
			&i.RentingID,
			&i.TransactionReference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRent = `-- name: GetRent :one
SELECT price FROM pricing_history 
WHERE is_current = 1 AND apartment_id = ?
`

func (q *Queries) GetRent(ctx context.Context, apartmentID int64) (float64, error) {
	row := q.db.QueryRowContext(ctx, getRent, apartmentID)
	var price float64
	err := row.Scan(&price)
	return price, err
}

const getRepair = `-- name: GetRepair :many
SELECT repair.id, repair.title, repair.fault_report_id, repair.date_assigned, repair.date_completed, repair.status_id, repair.subcontractor_id, user.name FROM repair
LEFT JOIN subcontractor ON repair.subcontractor_id = subcontractor.id
LEFT JOIN user ON subcontractor.user_id = user.id
`

type GetRepairRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	FaultReportID   int64          `json:"fault_report_id"`
	DateAssigned    time.Time      `json:"date_assigned"`
	DateCompleted   types.JSONNullTime   `json:"date_completed"`
	StatusID        int64          `json:"status_id"`
	SubcontractorID types.JSONNullInt64  `json:"subcontractor_id"`
	Name            types.JSONNullString `json:"name"`
}

func (q *Queries) GetRepair(ctx context.Context) ([]GetRepairRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepair)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepairRow
	for rows.Next() {
		var i GetRepairRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.FaultReportID,
			&i.DateAssigned,
			&i.DateCompleted,
			&i.StatusID,
			&i.SubcontractorID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepairApart = `-- name: GetRepairApart :many
SELECT repair.id, repair.title, repair.fault_report_id, repair.date_assigned, repair.date_completed, repair.status_id, repair.subcontractor_id, user.name FROM repair
LEFT JOIN subcontractor ON repair.subcontractor_id = subcontractor.id
LEFT JOIN user ON subcontractor.user_id = user.id
WHERE fault_report_id = (SELECT id FROM fault_report WHERE apartment_id = ?)
`

type GetRepairApartRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	FaultReportID   int64          `json:"fault_report_id"`
	DateAssigned    time.Time      `json:"date_assigned"`
	DateCompleted   types.JSONNullTime   `json:"date_completed"`
	StatusID        int64          `json:"status_id"`
	SubcontractorID types.JSONNullInt64  `json:"subcontractor_id"`
	Name            types.JSONNullString `json:"name"`
}

func (q *Queries) GetRepairApart(ctx context.Context, apartmentID int64) ([]GetRepairApartRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepairApart, apartmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepairApartRow
	for rows.Next() {
		var i GetRepairApartRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.FaultReportID,
			&i.DateAssigned,
			&i.DateCompleted,
			&i.StatusID,
			&i.SubcontractorID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepairSub = `-- name: GetRepairSub :many
SELECT repair.id, repair.title, repair.fault_report_id, repair.date_assigned, repair.date_completed, repair.status_id, repair.subcontractor_id, user.name FROM repair
LEFT JOIN subcontractor ON repair.subcontractor_id = subcontractor.id
LEFT JOIN user ON subcontractor.user_id = user.id
WHERE subcontractor_id = (SELECT id FROM subcontractor WHERE subcontractor.user_id = ?)
`

type GetRepairSubRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	FaultReportID   int64          `json:"fault_report_id"`
	DateAssigned    time.Time      `json:"date_assigned"`
	DateCompleted   types.JSONNullTime   `json:"date_completed"`
	StatusID        int64          `json:"status_id"`
	SubcontractorID types.JSONNullInt64  `json:"subcontractor_id"`
	Name            types.JSONNullString `json:"name"`
}

func (q *Queries) GetRepairSub(ctx context.Context, userID int64) ([]GetRepairSubRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepairSub, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepairSubRow
	for rows.Next() {
		var i GetRepairSubRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.FaultReportID,
			&i.DateAssigned,
			&i.DateCompleted,
			&i.StatusID,
			&i.SubcontractorID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubconInfo = `-- name: GetSubconInfo :one
SELECT address, NIP, speciality_id FROM subcontractor 
WHERE user_id = ?
`

type GetSubconInfoRow struct {
	Address      string `json:"address"`
	Nip          string `json:"nip"`
	SpecialityID int64  `json:"speciality_id"`
}

func (q *Queries) GetSubconInfo(ctx context.Context, userID int64) (GetSubconInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getSubconInfo, userID)
	var i GetSubconInfoRow
	err := row.Scan(&i.Address, &i.Nip, &i.SpecialityID)
	return i, err
}

const getSubcontractorSpec = `-- name: GetSubcontractorSpec :many
SELECT id, name FROM speciality
`

func (q *Queries) GetSubcontractorSpec(ctx context.Context) ([]Speciality, error) {
	rows, err := q.db.QueryContext(ctx, getSubcontractorSpec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Speciality
	for rows.Next() {
		var i Speciality
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubcontractors = `-- name: GetSubcontractors :many
SELECT subcontractor.id, subcontractor.user_id, subcontractor.address, subcontractor.nip, subcontractor.speciality_id, user.name FROM subcontractor
INNER JOIN user ON subcontractor.user_id = user.id
`

type GetSubcontractorsRow struct {
	ID           int64  `json:"id"`
	UserID       int64  `json:"user_id"`
	Address      string `json:"address"`
	Nip          string `json:"nip"`
	SpecialityID int64  `json:"speciality_id"`
	Name         string `json:"name"`
}

func (q *Queries) GetSubcontractors(ctx context.Context) ([]GetSubcontractorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubcontractors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubcontractorsRow
	for rows.Next() {
		var i GetSubcontractorsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Address,
			&i.Nip,
			&i.SpecialityID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenets = `-- name: GetTenets :many
SELECT id, name, email, phone, role_id FROM user WHERE role_id = "2"
`

type GetTenetsRow struct {
	ID     int64  `json:"id"`
	Name   string `json:"name"`
	Email  string `json:"email"`
	Phone  string `json:"phone"`
	RoleID int64  `json:"role_id"`
}

func (q *Queries) GetTenets(ctx context.Context) ([]GetTenetsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTenets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTenetsRow
	for rows.Next() {
		var i GetTenetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.RoleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenetsWithRent = `-- name: GetTenetsWithRent :many
SELECT user.id, user.name, user.email, user.phone, 
  apartment.id, apartment.name, pricing_history.price
FROM user 
LEFT JOIN renting_history ON renting_history.user_id = user.id 
LEFT JOIN apartment ON renting_history.apartment_id = apartment.id
AND renting_history.is_current = 1
LEFT JOIN pricing_history ON pricing_history.apartment_id = apartment.id
AND pricing_history.is_current = 1
WHERE role_id = "2"
`

type GetTenetsWithRentRow struct {
	ID     int64           `json:"id"`
	Name   string          `json:"name"`
	Email  string          `json:"email"`
	Phone  string          `json:"phone"`
	ID_2   types.JSONNullInt64   `json:"id_2"`
	Name_2 types.JSONNullString  `json:"name_2"`
	Price  types.JSONNullFloat `json:"price"`
}

func (q *Queries) GetTenetsWithRent(ctx context.Context) ([]GetTenetsWithRentRow, error) {
	rows, err := q.db.QueryContext(ctx, getTenetsWithRent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTenetsWithRentRow
	for rows.Next() {
		var i GetTenetsWithRentRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.ID_2,
			&i.Name_2,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserId = `-- name: GetUserId :one
SELECT id FROM user 
WHERE email = ?
`

func (q *Queries) GetUserId(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserId, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserInfo = `-- name: GetUserInfo :one
SELECT id, name, phone, role_id FROM user 
WHERE id = ?
`

type GetUserInfoRow struct {
	ID     int64  `json:"id"`
	Name   string `json:"name"`
	Phone  string `json:"phone"`
	RoleID int64  `json:"role_id"`
}

func (q *Queries) GetUserInfo(ctx context.Context, id int64) (GetUserInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getUserInfo, id)
	var i GetUserInfoRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.RoleID,
	)
	return i, err
}

const getUserPassword = `-- name: GetUserPassword :one
SELECT password FROM user 
WHERE id = ?
`

func (q *Queries) GetUserPassword(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserPassword, id)
	var password string
	err := row.Scan(&password)
	return password, err
}

const getUserPasswordEmail = `-- name: GetUserPasswordEmail :one
SELECT id, password FROM user 
WHERE email = ?
`

type GetUserPasswordEmailRow struct {
	ID       int64  `json:"id"`
	Password string `json:"password"`
}

func (q *Queries) GetUserPasswordEmail(ctx context.Context, email string) (GetUserPasswordEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserPasswordEmail, email)
	var i GetUserPasswordEmailRow
	err := row.Scan(&i.ID, &i.Password)
	return i, err
}

const getUserRole = `-- name: GetUserRole :one
SELECT role.name FROM user 
JOIN role ON role.id = user.role_id
WHERE user.id = ?
`

func (q *Queries) GetUserRole(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserRole, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const makeAsEnd = `-- name: MakeAsEnd :exec
UPDATE renting_history SET is_current = 0 WHERE id = ?
`

func (q *Queries) MakeAsEnd(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, makeAsEnd, id)
	return err
}

const setEndDate = `-- name: SetEndDate :exec
UPDATE renting_history SET end_date = ? WHERE id = ?
`

type SetEndDateParams struct {
	EndDate types.JSONNullTime `json:"end_date"`
	ID      int64        `json:"id"`
}

func (q *Queries) SetEndDate(ctx context.Context, arg SetEndDateParams) error {
	_, err := q.db.ExecContext(ctx, setEndDate, arg.EndDate, arg.ID)
	return err
}

const setPaymanyOverdue = `-- name: SetPaymanyOverdue :one
UPDATE payments
SET status_id = 3
WHERE id = ?
RETURNING id, amount, payment_date, due_date, status_id, renting_id, transaction_reference
`

func (q *Queries) SetPaymanyOverdue(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRowContext(ctx, setPaymanyOverdue, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.PaymentDate,
		&i.DueDate,
		&i.StatusID,
		&i.RentingID,
		&i.TransactionReference,
	)
	return i, err
}

const updateFaultStatus = `-- name: UpdateFaultStatus :one
UPDATE fault_report
SET status_id = ?
WHERE id = ?
RETURNING id, title, description, date_reported, status_id, apartment_id, user_id
`

type UpdateFaultStatusParams struct {
	StatusID int64 `json:"status_id"`
	ID       int64 `json:"id"`
}

func (q *Queries) UpdateFaultStatus(ctx context.Context, arg UpdateFaultStatusParams) (FaultReport, error) {
	row := q.db.QueryRowContext(ctx, updateFaultStatus, arg.StatusID, arg.ID)
	var i FaultReport
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.DateReported,
		&i.StatusID,
		&i.ApartmentID,
		&i.UserID,
	)
	return i, err
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
SET status_id = 2, transaction_reference = ?, payment_date = ?
WHERE id = ?
RETURNING id, amount, payment_date, due_date, status_id, renting_id, transaction_reference
`

type UpdatePaymentParams struct {
	TransactionReference types.JSONNullString `json:"transaction_reference"`
	PaymentDate          types.JSONNullTime   `json:"payment_date"`
	ID                   int64          `json:"id"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, updatePayment, arg.TransactionReference, arg.PaymentDate, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.PaymentDate,
		&i.DueDate,
		&i.StatusID,
		&i.RentingID,
		&i.TransactionReference,
	)
	return i, err
}

const updateRepairData = `-- name: UpdateRepairData :one
UPDATE repair
SET status_id = (SELECT id FROM repair_status WHERE name = ?), date_completed = ?
WHERE repair.id = ?
RETURNING id, title, fault_report_id, date_assigned, date_completed, status_id, subcontractor_id
`

type UpdateRepairDataParams struct {
	Name          string       `json:"name"`
	DateCompleted types.JSONNullTime `json:"date_completed"`
	ID            int64        `json:"id"`
}

func (q *Queries) UpdateRepairData(ctx context.Context, arg UpdateRepairDataParams) (Repair, error) {
	row := q.db.QueryRowContext(ctx, updateRepairData, arg.Name, arg.DateCompleted, arg.ID)
	var i Repair
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.FaultReportID,
		&i.DateAssigned,
		&i.DateCompleted,
		&i.StatusID,
		&i.SubcontractorID,
	)
	return i, err
}

const updateSubToRepair = `-- name: UpdateSubToRepair :one
UPDATE repair
SET subcontractor_id = ?
WHERE id = ?
RETURNING id, title, fault_report_id, date_assigned, date_completed, status_id, subcontractor_id
`

type UpdateSubToRepairParams struct {
	SubcontractorID types.JSONNullInt64 `json:"subcontractor_id"`
	ID              int64         `json:"id"`
}

func (q *Queries) UpdateSubToRepair(ctx context.Context, arg UpdateSubToRepairParams) (Repair, error) {
	row := q.db.QueryRowContext(ctx, updateSubToRepair, arg.SubcontractorID, arg.ID)
	var i Repair
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.FaultReportID,
		&i.DateAssigned,
		&i.DateCompleted,
		&i.StatusID,
		&i.SubcontractorID,
	)
	return i, err
}
